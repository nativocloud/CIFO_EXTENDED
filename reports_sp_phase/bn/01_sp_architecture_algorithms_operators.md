# একক-প্রসেসর ধাপের প্রতিবেদন - টিম নির্বাচনের জন্য মেটাহিউরিস্টিক অ্যালগরিদম অপ্টিমাইজেশান

**CIFO টিম**

**তারিখ:** মে ১৫, ২০২৫

## ১. ভূমিকা

এই ডকুমেন্টটি CIFO টিমের তৈরি করা প্রকল্পের প্রথম ধাপের বিস্তারিত বর্ণনা করে, যা একক-প্রসেসর পরিবেশে ক্রীড়া দলের নির্বাচন অপ্টিমাইজেশান সমস্যার জন্য মেটাহিউরিস্টিক অ্যালগরিদমগুলির বাস্তবায়ন এবং বিশ্লেষণের উপর দৃষ্টি নিবদ্ধ করে। এই ধাপের প্রধান উদ্দেশ্য ছিল বিভিন্ন অ্যালগরিদম এবং অপারেটর প্রয়োগ করে একটি শক্ত ভিত্তি স্থাপন করা এবং আরও উন্নত অপ্টিমাইজেশান এবং সমান্তরালকরণের আগে তাদের কর্মক্ষমতা এবং বৈশিষ্ট্যগুলি সনাক্ত করা।

সমস্যাটি হলো উপলব্ধ খেলোয়াড়দের একটি পুল থেকে একাধিক দল গঠন করা, কিছু সীমাবদ্ধতা (বাজেট, প্রতি দলে খেলোয়াড়ের সংখ্যা, অবস্থানগত প্রয়োজনীয়তা) মেনে চলা এবং একটি নির্দিষ্ট মানদণ্ড অপ্টিমাইজ করা (এই ক্ষেত্রে, গঠিত দলগুলির মধ্যে গড় দক্ষতার তারতম্য হ্রাস করা)।

এই প্রতিবেদনে প্রাথমিক কোড আর্কিটেকচার, সমাধানের উপস্থাপনা, নির্বাচিত ডেটা কাঠামো, বাস্তবায়িত অ্যালগরিদমসমূহ (হিল ক্লাইম্বিং, সিমুলেটেড অ্যানিলিং, এবং বিভিন্ন অপারেটর সহ জেনেটিক অ্যালগরিদম), নকশা পছন্দের পেছনের যুক্তি এবং প্রাথমিক কর্মক্ষমতার ফলাফল বর্ণনা করা হবে।

## ২. একক-প্রসেসর কোড আর্কিটেকচার (প্রাথমিক সংস্করণ)

একক-প্রসেসর ধাপের জন্য কোড আর্কিটেকচারটি মডুলারভাবে ডিজাইন করা হয়েছিল যাতে মেটাহিউরিস্টিক অ্যালগরিদমগুলির বিভিন্ন উপাদানগুলির বাস্তবায়ন, পরীক্ষা এবং প্রতিস্থাপন সহজতর হয়। এই আর্কিটেকচারে জড়িত প্রধান পাইথন ফাইলগুলি হলো:

*   `solution.py`: সমস্যার সমাধানের একটি উপস্থাপনা (খেলোয়াড়দের দলে przypisanie) এবং এর বৈধতা এবং গুণমান (ফিটনেস) মূল্যায়নের পদ্ধতিগুলি সংজ্ঞায়িত করে। এটি প্রতিবেশী সমাধান তৈরি বা বিদ্যমান সমাধানগুলি পরিবর্তন করার পদ্ধতিও অন্তর্ভুক্ত করে।
*   `evolution.py`: প্রধান মেটাহিউরিস্টিক অ্যালগরিদমগুলির বাস্তবায়ন ধারণ করে: হিল ক্লাইম্বিং, সিমুলেটেড অ্যানিলিং এবং জেনেরিক জেনেটিক অ্যালগরিদম।
*   `operators.py`: জেনেটিক অ্যালগরিদম দ্বারা ব্যবহৃত বিভিন্ন জেনেটিক অপারেটর যেমন নির্বাচন, ক্রসওভার এবং মিউটেশন অপারেটর প্রয়োগ করে।
*   `main_script_sp.py`: প্রধান স্ক্রিপ্ট যা অ্যালগরিদমগুলির সম্পাদনকে অর্কেস্ট্রেট করে, খেলোয়াড়ের ডেটা লোড করে, অ্যালগরিদমের প্যারামিটারগুলি কনফিগার করে এবং ফলাফল সংগ্রহ/উপস্থাপন করে।

### ২.১. সমাধানের উপস্থাপনা এবং ডেটা কাঠামো

সমাধানের উপস্থাপনা এবং ডেটা কাঠামোর পছন্দের পেছনের যুক্তি ছিল প্রয়োজনীয় ক্রিয়াকলাপগুলির জন্য সরলতা এবং দক্ষতা।

*   **সমাধানের উপস্থাপনা (`LeagueSolution` `solution.py`-তে):** একটি সমাধান একটি তালিকা (বা পরে, একটি NumPy অ্যারে) হিসাবে উপস্থাপিত হয় যেখানে সূচকটি একজন খেলোয়াড়ের আইডির সাথে সঙ্গতিপূর্ণ এবং সেই সূচকের মানটি সেই খেলোয়াড়কে যে দলের আইডিতে przypisano হয়েছে তার সাথে সঙ্গতিপূর্ণ। উদাহরণস্বরূপ, `assignment[player_id] = team_id`।
    *   **যুক্তি:** এই উপস্থাপনাটি সহজবোধ্য, পরিচালনা করা সহজ এবং যেকোনো খেলোয়াড়ের দলে দ্রুত অ্যাক্সেসের অনুমতি দেয়। এটি সংক্ষিপ্তও।

*   **খেলোয়াড়ের ডেটা:** খেলোয়াড়ের ডেটা (আইডি, নাম, অবস্থান, বেতন, দক্ষতা) প্রাথমিকভাবে একটি CSV ফাইল থেকে একটি সুবিধাজনক ডেটা কাঠামোতে (যেমন অভিধানের তালিকা বা একটি Pandas DataFrame) প্রধান স্ক্রিপ্টে লোড করা হয়। সমাধান এবং অ্যালগরিদম ক্লাসগুলির অভ্যন্তরীণ ক্রিয়াকলাপগুলির জন্য, এই ডেটা প্রায়শই গণনার জন্য আরও অপ্টিমাইজ করা ফর্ম্যাটে পাস বা রূপান্তরিত হয় (যেমন বেতন, দক্ষতা এবং সংখ্যাসূচক অবস্থানগুলির জন্য NumPy অ্যারে, যেমন ভেক্টরাইজেশন পর্যায়ে করা হয়েছিল)।
    *   **যুক্তি:** CSV ডেটা ইনপুটের জন্য একটি সাধারণ এবং সহজেই ব্যবহারযোগ্য ফর্ম্যাট। অভ্যন্তরীণভাবে, NumPy অ্যারেতে রূপান্তর (বিশেষত ভেক্টরাইজেশনের পরে) সংখ্যাসূচক গণনা ত্বরান্বিত করার লক্ষ্যে করা হয়।

*   **টিম কাঠামো:** অন্তর্নিহিতভাবে, দলগুলি খেলোয়াড়দের সংগ্রহ। সমাধানের উপস্থাপনা প্রতিটি দলের গঠন সহজে পুনর্গঠনের অনুমতি দেয়, খেলোয়াড়দের তাদের przypisano `team_id`-এর উপর ভিত্তি করে ফিল্টার করে।

### ২.২. বাস্তবায়িত অ্যালগরিদম (প্রাথমিক, অপ্টিমাইজ না করা সংস্করণ)

এই প্রাথমিক পর্যায়ে তিন ধরনের প্রধান মেটাহিউরিস্টিক অ্যালগরিদম নির্বাচন করা হয়েছিল, তাদের জনপ্রিয়তা এবং সমাধান স্থান অনুসন্ধানের বিভিন্ন পদ্ধতির কারণে:

1.  **হিল ক্লাইম্বিং (HC):**
    *   **বর্ণনা:** একটি পুনরাবৃত্তিমূলক স্থানীয় অনুসন্ধান অ্যালগরিদম যা একটি নির্বিচারে সমাধান দিয়ে শুরু হয় এবং আরও ভাল ফিটনেস সহ প্রতিবেশীর দিকে অগ্রসর হয়ে আরও ভাল সমাধান খুঁজে বের করার চেষ্টা করে। এটি যখন একটি স্থানীয় সর্বোত্তমে পৌঁছায় তখন শেষ হয়, যেখানে কোনও প্রতিবেশীর আরও ভাল ফিটনেস নেই।
    *   **নির্বাচনের যুক্তি:** এটি বাস্তবায়ন এবং বোঝার জন্য সবচেয়ে সহজ অপ্টিমাইজেশান অ্যালগরিদমগুলির মধ্যে একটি। এটি আরও জটিল অ্যালগরিদমগুলির সাথে তুলনার জন্য একটি ভাল ভিত্তি হিসাবে কাজ করে। এটি দ্রুত কিন্তু স্থানীয় সর্বোত্তমগুলিতে আটকে যাওয়ার প্রবণতা রয়েছে।

2.  **সিমুলেটেড অ্যানিলিং (SA):**
    *   **বর্ণনা:** ধাতুবিদ্যায় অ্যানিলিং প্রক্রিয়া দ্বারা অনুপ্রাণিত একটি সম্ভাব্যতাভিত্তিক অপ্টিমাইজেশান কৌশল। এটি একটি নির্দিষ্ট সম্ভাবনার সাথে আরও খারাপ সমাধানের দিকে অগ্রসর হওয়ার অনুমতি দেয়, যা অ্যালগরিদম অগ্রসর হওয়ার সাথে সাথে হ্রাস পায় ("তাপমাত্রা" কমে যায়)। এটি স্থানীয় সর্বোত্তমগুলি থেকে পালাতে সহায়তা করে।
    *   **নির্বাচনের যুক্তি:** এটি হিল ক্লাইম্বিংয়ের চেয়ে ভাল বিশ্বব্যাপী অনুসন্ধান ক্ষমতা সরবরাহ করে, স্থানীয় সর্বোত্তমগুলি এড়ানোর ক্ষমতা সহ। এর কার্যকারিতা কুলিং সময়সূচীর সঠিক প্যারামিটারাইজেশনের উপর নির্ভর করে।

3.  **জেনেটিক অ্যালগরিদম (GAs):**
    *   **বর্ণনা:** জৈবিক বিবর্তন দ্বারা অনুপ্রাণিত অনুসন্ধান অ্যালগরিদম। তারা প্রার্থী সমাধানগুলির একটি জনসংখ্যা বজায় রাখে যা নির্বাচন, ক্রসওভার (পুনর্মিলন) এবং মিউটেশনের মতো জেনেটিক অপারেটরগুলির মাধ্যমে প্রজন্মের পর প্রজন্ম ধরে বিকশিত হয়।
    *   **নির্বাচনের যুক্তি:** এগুলি জটিল অপ্টিমাইজেশান সমস্যার জন্য শক্তিশালী এবং বৃহৎ সমাধান স্থানগুলি কার্যকরভাবে অনুসন্ধান করতে পারে। তাদের জনসংখ্যা-ভিত্তিক প্রকৃতি বৈচিত্র্য বজায় রাখতে এবং অনুসন্ধান স্থানের একাধিক অঞ্চল একযোগে অন্বেষণ করতে দেয়।

### ২.৩. পরীক্ষার জন্য অপারেটর নির্বাচন (জেনেটিক অ্যালগরিদম)

জেনেটিক অ্যালগরিদমগুলির জন্য, বিভিন্ন বিবর্তনীয় কৌশল পরীক্ষার অনুমতি দেওয়ার জন্য বিভিন্ন অপারেটর প্রয়োগ করা হয়েছিল:

*   **নির্বাচন অপারেটর:** বর্তমান জনসংখ্যা থেকে কোন ব্যক্তিরা প্রজননের জন্য নির্বাচিত হবে তা নির্ধারণ করে।
    *   `selection_tournament`: টুর্নামেন্ট নির্বাচন। জনসংখ্যা থেকে এলোমেলোভাবে বেশ কয়েকটি ব্যক্তি নির্বাচন করা হয় এবং তাদের মধ্যে সেরাটি নির্বাচন করা হয়।
        *   **যুক্তি:** বাস্তবায়ন করা সহজ, দক্ষ এবং টুর্নামেন্টের আকারের মাধ্যমে নির্বাচনী চাপের উপর নিয়ন্ত্রণের অনুমতি দেয়।
    *   `selection_roulette_wheel`: রুলেট হুইল নির্বাচন। একজন ব্যক্তির নির্বাচিত হওয়ার সম্ভাবনা তার ফিটনেসের সমানুপাতিক।
        *   **যুক্তি:** একটি ক্লাসিক পদ্ধতি যা সমস্ত ব্যক্তিকে সুযোগ দেয় তবে সবচেয়ে উপযুক্তদের পক্ষে থাকে।
    *   `selection_ranking`: র‍্যাঙ্ক-ভিত্তিক নির্বাচন। ব্যক্তিদের তাদের ফিটনেস অনুসারে বাছাই করা হয় এবং নির্বাচনের সম্ভাবনা তাদের র‍্যাঙ্কের উপর ভিত্তি করে হয়, পরম ফিটনেস মানের উপর নয়।
        *   **যুক্তি:** অকাল অভিসারের সমস্যাগুলি এড়িয়ে যায় যা রুলেট হুইলের সাথে ঘটতে পারে যদি অন্যদের তুলনায় অনেক বেশি ফিটনেস সহ ব্যক্তি থাকে।
    *   `selection_boltzmann` (বাস্তবায়িত, তবে কার্যকর হওয়ার জন্য তাপমাত্রা সমন্বয়ের প্রয়োজন হতে পারে):
        *   **যুক্তি:** বোল্টজম্যান অনুসন্ধান দ্বারা অনুপ্রাণিত, সময়ের সাথে সাথে নির্বাচনী চাপ সামঞ্জস্য করে।

*   **ক্রসওভার অপারেটর:** দুই পিতামাতার জেনেটিক উপাদান একত্রিত করে এক বা একাধিক সন্তান তৈরি করে।
    *   `crossover_one_point`: এক-বিন্দু ক্রসওভার। একটি কাট পয়েন্ট এলোমেলোভাবে বেছে নেওয়া হয় এবং সন্তানদের গঠনের জন্য পিতামাতার অংশগুলি অদলবদল করা হয়।
    *   `crossover_uniform`: অভিন্ন ক্রসওভার। প্রতিটি জিনের জন্য (অ্যাসাইনমেন্ট অ্যারেতে অবস্থান), এলোমেলোভাবে সিদ্ধান্ত নেওয়া হয় যে সন্তান কোন পিতামাতার কাছ থেকে সেই জিনটি উত্তরাধিকার সূত্রে পাবে।
    *   `_prefer_valid` সংস্করণ: এই অপারেটরগুলির বিভিন্ন সংস্করণও অন্বেষণ করা হয়েছিল যা সরাসরি বৈধ সন্তান তৈরি করার চেষ্টা করে বা অবৈধ সন্তানদের মেরামত করার প্রক্রিয়া রয়েছে (যদিও প্রধান বৈধতা সন্তান তৈরির পরে ঘটে)।
        *   **বৈচিত্র্যের যুক্তি:** বিভিন্ন ক্রসওভার অপারেটর বিভিন্ন উপায়ে সমাধান স্থান অন্বেষণ করে। এক-বিন্দু ক্রসওভার জিনের ব্লকগুলি সংরক্ষণ করার প্রবণতা রাখে, যখন অভিন্ন ক্রসওভার বৃহত্তর মিশ্রণকে উৎসাহিত করে।

*   **মিউটেশন অপারেটর:** জেনেটিক বৈচিত্র্য বজায় রাখতে এবং সমাধান স্থানের নতুন ক্ষেত্রগুলি অন্বেষণের অনুমতি দেওয়ার জন্য ব্যক্তিদের মধ্যে ছোট এলোমেলো পরিবর্তন প্রবর্তন করে।
    *   `mutation_random_player_team_change`: এলোমেলোভাবে নির্বাচিত খেলোয়াড়ের দল এলোমেলোভাবে পরিবর্তন করে।
    *   `mutation_swap_players_between_teams`: দুটি ভিন্ন দলের মধ্যে দুজন খেলোয়াড় অদলবদল করে।
    *   `mutation_swap_players_different_teams_specific_roles` (আরও জটিল, প্রাথমিকভাবে সরলীকৃত বা আরও জেনেরিক অদলবদলের উপর দৃষ্টি নিবদ্ধ করা হতে পারে): দলগুলির মধ্যে নির্দিষ্ট ভূমিকার খেলোয়াড়দের অদলবদল করার চেষ্টা করে।
        *   **বৈচিত্র্যের যুক্তি:** বিভিন্ন ধরনের মিউটেশন সমাধান স্থানে বিভিন্ন ধরনের "লাফ" দেওয়ার অনুমতি দেয়। সাধারণ মিউটেশনগুলি কম বিঘ্নিতকারী, যখন আরও জটিল মিউটেশনগুলি স্থানীয় সর্বোত্তমগুলি থেকে আরও সহজে পালাতে দেয় তবে সেগুলি দ্রুত বৈধ সমাধানে পরিণত হবে তা নিশ্চিত করা আরও কঠিন হতে পারে।

CIFO টিমের এই অ্যালগরিদম এবং অপারেটরগুলির প্রাথমিক নির্বাচনটি মেটাহিউরিস্টিক পদ্ধতির একটি বর্ণালী কভার করার লক্ষ্যে করা হয়েছিল, সবচেয়ে সহজ (HC) থেকে সবচেয়ে জটিল এবং জনসংখ্যা-ভিত্তিক (একাধিক অপারেটর সহ GAs) পর্যন্ত, নির্দিষ্ট দল গঠন সমস্যায় তাদের উপযুক্ততা এবং কর্মক্ষমতা মূল্যায়ন করার জন্য।

## ৩. প্রাথমিক অপ্টিমাইজেশানের ফলাফল (একক প্রসেসর)

অ্যালগরিদমগুলির প্রাথমিক বাস্তবায়নের পরে, CIFO টিম একক-প্রসেসর কোডের একটি প্রোফাইলিং এবং অপ্টিমাইজেশান পর্যায়ে অগ্রসর হয়েছিল। লক্ষ্য ছিল সমান্তরালকরণের কথা বিবেচনা করার আগে প্রধান কর্মক্ষমতার বাধাগুলি সনাক্ত করা এবং প্রশমিত করা। দুটি প্রধান অপ্টিমাইজেশান ক্ষেত্র `deepcopy`-এর ব্যবহার হ্রাস এবং গুরুত্বপূর্ণ ফাংশনগুলির ভেক্টরাইজেশনের উপর দৃষ্টি নিবদ্ধ করেছিল।

### ৩.১. প্রাথমিক প্রোফাইলিং এবং বাধা সনাক্তকরণ

`main_script_sp_timing_estimate.py` স্ক্রিপ্টের সম্পাদন (প্রতি অ্যালগরিদমে ১টি রান এবং জেনেটিক অ্যালগরিদমগুলির জন্য ১টি প্রজন্মের জন্য কনফিগার করা) প্রকাশ করেছে যে মোট সম্পাদনের সময় ছিল প্রায় **৮৫.৬৬ সেকেন্ড**। `cProfile` সহ প্রোফাইলিং বিশ্লেষণ নিম্নলিখিত বিষয়গুলিকে সবচেয়ে বেশি সময় ব্যয়কারী হিসাবে তুলে ধরেছে:

*   **সিমুলেটেড অ্যানিলিং (SA):** এটি ছিল সবচেয়ে ধীরগতির স্বতন্ত্র অ্যালগরিদম, যা প্রায় **৭৩.১৭ সেকেন্ড** (মোট স্ক্রিপ্ট সময়ের প্রায় ৮৫%) ব্যয় করেছিল।
*   **`copy.deepcopy`:** এই অপারেশনটিকে ধীরগতির প্রধান কারণ হিসাবে চিহ্নিত করা হয়েছিল, বিশেষত সিমুলেটেড অ্যানিলিংয়ের মধ্যে। এটি ২৩ মিলিয়নেরও বেশি বার কল করা হয়েছিল, যা সম্পাদনের সময়ের **৫৩.৪৯ সেকেন্ড** মোট করেছিল।
*   **সমাধান ফাংশন:** `solution.py:178(get_random_neighbor)` (SA দ্বারা ব্যবহৃত), `solution.py:122(fitness)`, এবং `solution.py:85(is_valid)` ফাংশনগুলিও সময়ের উল্লেখযোগ্য অংশ ব্যয় করেছিল, প্রধানত SA-তে বিপুল সংখ্যক কল এবং `get_random_neighbor`-এর ক্ষেত্রে এর অভ্যন্তরীণ `deepcopy` ব্যবহারের কারণে।

### ৩.২. সিমুলেটেড অ্যানিলিংয়ে `deepcopy`-এর ব্যবহার অপ্টিমাইজেশান

SA-এর কর্মক্ষমতার উপর `deepcopy`-এর ব্যাপক প্রভাবের কারণে, CIFO টিমের দ্বারা বাস্তবায়িত প্রথম অপ্টিমাইজেশানটি এর ব্যবহার হ্রাস করার লক্ষ্যে করা হয়েছিল।

*   **বাস্তবায়িত পরিবর্তন:** `simulated_annealing` ফাংশনে (`evolution.py`-তে), `current_solution` আপডেট করার জন্য `deepcopy(neighbor_solution)`-এ কলগুলি (যখন একটি ভাল সমাধান পাওয়া গিয়েছিল এবং যখন একটি খারাপ সমাধান সম্ভাব্যতাভিত্তিক ভাবে গৃহীত হয়েছিল উভয় ক্ষেত্রেই) সরাসরি przypisanie (`current_solution = neighbor_solution`) দ্বারা প্রতিস্থাপিত হয়েছিল।
*   **যুক্তি:** এই পরিবর্তনটিকে নিরাপদ বলে মনে করা হয়েছিল কারণ `get_random_neighbor` ফাংশন (`solution.py`-তে) ইতিমধ্যে একটি *নতুন সমাধান অবজেক্ট* (প্রতিবেশী) তৈরি এবং ফেরত দিয়েছিল যা একটি স্বাধীন উদাহরণ ছিল। বিশ্বব্যাপী `best_solution` আপডেট করার জন্য `deepcopy`-তে কলটি এর অখণ্ডতা নিশ্চিত করার জন্য বজায় রাখা হয়েছিল।
*   **প্রভাব:** এই অপ্টিমাইজেশানের ফলে কর্মক্ষমতার একটি অত্যন্ত তাৎপর্যপূর্ণ উন্নতি হয়েছিল:
    *   মোট স্ক্রিপ্ট সময় ৮৫.৬৬ সেকেন্ড থেকে **৪১.৪২ সেকেন্ডে** হ্রাস পেয়েছে (প্রায় ৫১.৭% উন্নতি)।
    *   `simulated_annealing` ফাংশনের নির্দিষ্ট সময় ৭৩.১৭ সেকেন্ড থেকে **২৮.৯১ সেকেন্ডে** হ্রাস পেয়েছে (প্রায় ৬০.৫% উন্নতি)।
    *   স্ক্রিপ্টে `deepcopy`-তে মোট কলের সংখ্যা নাটকীয়ভাবে হ্রাস পেয়েছে।
    *   অ্যালগরিদমগুলির দ্বারা অর্জিত সমাধানের গুণমান (ফিটনেস) একই ছিল।

### ৩.৩. `is_valid()` এবং `fitness()` ফাংশনগুলির ভেক্টরাইজেশান

দ্বিতীয় অপ্টিমাইজেশান প্রচেষ্টা `solution.py`-তে `is_valid()` এবং `fitness()` ফাংশনগুলির ভেক্টরাইজেশনের উপর দৃষ্টি নিবদ্ধ করেছিল, পাইথন লুপগুলিকে আরও দক্ষ অ্যারে অপারেশনগুলির সাথে প্রতিস্থাপন করার জন্য NumPy ব্যবহার করে।

*   **বাস্তবায়িত পরিবর্তন:**
    1.  **ডেটা প্রিপ্রসেসিং:** `LeagueSolution` ক্লাস কনস্ট্রাক্টরে, খেলোয়াড়ের ডেটা (বেতন, দক্ষতা, অবস্থান) NumPy অ্যারে হিসাবে রূপান্তরিত এবং সংরক্ষণ করা হয়েছিল।
    2.  **`is_valid()` পুনর্লিখন:** দলের আকার, বাজেট এবং অবস্থানগত প্রয়োজনীয়তার জন্য পরীক্ষাগুলি `np.bincount`, বুলিয়ান মাস্ক এবং `np.array_equal`-এর মতো NumPy অপারেশনগুলি ব্যবহার করে পুনর্লিখন করা হয়েছিল।
    3.  **`fitness()` পুনর্লিখন:** প্রতি দলের গড় দক্ষতার গণনা `weights` আর্গুমেন্ট সহ `np.bincount` ব্যবহার করে অপ্টিমাইজ করা হয়েছিল এবং স্ট্যান্ডার্ড ডেভিয়েশন `np.std` দিয়ে গণনা করা হয়েছিল।
*   **যুক্তি:** উদ্দেশ্য ছিল এই ঘন ঘন কল করা ফাংশনগুলিকে অ্যারেতে সংখ্যাসূচক ক্রিয়াকলাপগুলির জন্য NumPy-এর দক্ষতার সুবিধা নিয়ে ত্বরান্বিত করা।
*   **প্রভাব:** ভেক্টরাইজেশান এবং সামঞ্জস্যের জন্য `evolution.py`, `operators.py`, এবং `main_script_sp_timing_estimate.py`-তে প্রয়োজনীয় সংশোধনগুলি প্রয়োগ করার পরে, সম্পূর্ণ স্ক্রিপ্ট সম্পাদন (SA-তে `deepcopy` অপ্টিমাইজেশান এবং ভেক্টরাইজেশান সহ) প্রায় **৪০.৯৬ সেকেন্ডের** মোট সময় নিয়েছিল।
    *   `deepcopy` অপ্টিমাইজেশানের (৪১.৪২ সেকেন্ড) পরের সময়ের সাথে তুলনা করলে, ভেক্টরাইজেশান, কলের বর্তমান প্রেক্ষাপটে (বেশিরভাগ ক্ষেত্রে এই ফাংশনগুলির জন্য একবারে একটি সমাধান), সামগ্রিক সম্পাদনের সময়ে কোনও অতিরিক্ত উল্লেখযোগ্য উন্নতি আনেনি। `is_valid` এবং `fitness` ফাংশনগুলি নিজেরাই বিচ্ছিন্নভাবে দ্রুততর হয়েছিল, কিন্তু মোট সময়ে তাদের অবদান ইতিমধ্যে কলের সংখ্যা হ্রাস বা SA-তে অন্যান্য কারণগুলির প্রাধান্যের কারণে হ্রাস পেয়েছিল।
    *   তবে, ভেক্টরাইজড বাস্তবায়নকে আরও শক্তিশালী এবং সম্ভাব্যভাবে আরও পরিমাপযোগ্য বলে মনে করা হয় যদি খেলোয়াড় বা দলের সংখ্যা উল্লেখযোগ্যভাবে বৃদ্ধি পায়, বা যদি অ্যালগরিদমগুলি সমাধানের ব্যাচগুলি মূল্যায়ন করার জন্য অভিযোজিত হয়।

একক-প্রসেসর ধাপের এই ফলাফলগুলি অ্যালগরিদমগুলির আচরণ এবং অপ্টিমাইজেশান কৌশলগুলির কার্যকারিতা সম্পর্কে মূল্যবান অন্তর্দৃষ্টি প্রদান করেছে, যা মাল্টিপ্রসেসিং অনুসন্ধানের পথ প্রশস্ত করেছে।

## ৪. একক-প্রসেসর ধাপের উপসংহার এবং পরবর্তী পদক্ষেপ

CIFO টিমের দ্বারা পরিচালিত একক-প্রসেসর বাস্তবায়ন এবং অপ্টিমাইজেশান পর্বটি টিম নির্বাচন সমস্যার জন্য একটি শক্ত ভিত্তি স্থাপনের জন্য অত্যন্ত গুরুত্বপূর্ণ ছিল। হিল ক্লাইম্বিং, সিমুলেটেড অ্যানিলিং এবং বিভিন্ন অপারেটর সহ জেনেটিক অ্যালগরিদমগুলির প্রাথমিক বাস্তবায়ন তাদের আচরণ এবং অন্তর্নিহিত গণনামূলক চ্যালেঞ্জগুলির একটি পুঙ্খানুপুঙ্খ বোঝার সুযোগ করে দিয়েছে।

প্রোফাইলিং একটি অপরিহার্য হাতিয়ার হিসাবে প্রমাণিত হয়েছে, সিমুলেটেড অ্যানিলিংয়ে `deepcopy`-এর অত্যধিক ব্যবহারকে প্রধান কর্মক্ষমতার বাধা হিসাবে চিহ্নিত করেছে। এই সমস্যার লক্ষ্যযুক্ত অপ্টিমাইজেশানের ফলে সম্পাদনের সময় উল্লেখযোগ্যভাবে হ্রাস পেয়েছে (মোট স্ক্রিপ্ট সময়ের প্রায় ৫১.৭%), সমাধানের গুণমানের সাথে আপস না করে। `is_valid()` এবং `fitness()` ফাংশনগুলির পরবর্তী ভেক্টরাইজেশান, যদিও এই নির্দিষ্ট কলিং প্রসঙ্গে উল্লেখযোগ্য অতিরিক্ত সময় লাভ প্রদান করেনি, কোডবেসকে আধুনিকীকরণ করেছে এবং এটিকে সম্ভাব্য আরও চাহিদাপূর্ণ পরিস্থিতির জন্য প্রস্তুত করেছে।
