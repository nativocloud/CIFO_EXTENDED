# মাল্টিপ্রসেসিং (এমপি) ধাপের আর্কিটেকচার ডকিউমেন্ট

**সংস্করণ:** ১.০
**তারিখ:** ১৫ মে, ২০২৫

## ১. ভূমিকা

এই ডকিউমেন্টটি CIFO এক্সটেন্ডেড প্রকল্পের মাল্টিপ্রসেসিং (এমপি) ধাপের জন্য বাস্তবায়িত সফ্টওয়্যার আর্কিটেকচার বর্ণনা করে। এই ধাপের প্রধান উদ্দেশ্য ছিল একক-প্রসেসর (এসপি) ধাপের আর্কিটেকচারকে প্রসারিত করা যাতে মেটাহিউরিস্টিক অ্যালগরিদমগুলির একাধিক দৃষ্টান্তের সমান্তরাল সম্পাদন করা যায়, যার লক্ষ্য পরিসংখ্যানগতভাবে আরও শক্তিশালী ফলাফল প্রাপ্ত করা এবং পরীক্ষামূলক প্রক্রিয়াকে ত্বরান্বিত করা।

## ২. এমপি আর্কিটেকচারের সংক্ষিপ্তসার

এমপি ধাপের আর্কিটেকচারটি এসপি ধাপে বিকশিত মডিউলগুলির (`solution.py`, `evolution.py`, `operators.py`) উপর ভিত্তি করে তৈরি করা হয়েছে, একটি নতুন প্রধান স্ক্রিপ্ট (`main_script_mp.py` এবং এর বিভিন্ন সংস্করণ যেমন `main_script_mp_30_runs.py`, `main_script_mp_param_var.py`, `main_script_mp_final_param_var.py`) প্রবর্তন করে যা পাইথনের `multiprocessing` মডিউল ব্যবহার করে সমান্তরাল সম্পাদনগুলি পরিচালনা করে।

এমপি আর্কিটেকচারের প্রধান অতিরিক্ত বা পরিবর্তিত উপাদানগুলি হল:

*   **মাল্টিপ্রসেসিং প্রধান স্ক্রিপ্ট (যেমন, `main_script_mp.py`):** এক বা একাধিক অ্যালগরিদমের একাধিক রানের সমান্তরাল সম্পাদন কনফিগার এবং পরিচালনা করার জন্য দায়ী। তারা কাজ বিতরণের জন্য প্রসেসের একটি `Pool` ব্যবহার করে।
*   **কর্মী সম্পাদন ফাংশন:** একটি র‍্যাপার ফাংশন যা একটি একক অ্যালগরিদম রানের যুক্তিকে এনক্যাপসুলেট করে, এটি একটি `Pool`-এর একটি প্রসেস দ্বারা সম্পাদনের জন্য উপযুক্ত করে তোলে।
*   **ফলাফল একত্রীকরণ:** পরবর্তী বিশ্লেষণের জন্য সমস্ত সমান্তরাল রান থেকে ফলাফল (ফিটনেস, সম্পাদনের সময়, ইত্যাদি) সংগ্রহ এবং একত্রিত করার প্রক্রিয়া।

## ৩. এমপি উপাদানগুলির বিবরণ

### ৩.১. মাল্টিপ্রসেসিং প্রধান স্ক্রিপ্ট

এই স্ক্রিপ্টগুলি এমপি ধাপের কেন্দ্রবিন্দু।

*   **উদাহরণ (`main_script_mp.py`):**
    *   **অ্যালগরিদম এবং রান কনফিগারেশন:** কোন অ্যালগরিদম এবং কোন প্যারামিটারগুলির সাথে সম্পাদন করা হবে এবং প্রতিটি কতবার পুনরাবৃত্তি করা উচিত (যেমন, ৫ রান, ৩০ রান) তা নির্ধারণ করে।
    *   **প্রসেস পুল তৈরি:** `multiprocessing.Pool()` ব্যবহার করে কর্মী প্রসেসগুলির একটি সেট তৈরি করে, সাধারণত উপলব্ধ সিপিইউ কোরগুলির সংখ্যা বা একটি কনফিগারযোগ্য মানের সাথে সঙ্গতিপূর্ণ।
    *   **টাস্ক প্রস্তুতি:** প্রতিটি প্রয়োজনীয় অ্যালগরিদম রানের জন্য, প্যারামিটারগুলি কর্মী ফাংশনে পাস করার জন্য প্যাকেজ করা হয় (যেমন, একটি টাপল বা অভিধানে)।
    *   **টাস্ক বিতরণ:** `Pool` প্রসেসগুলিতে টাস্ক জমা দেওয়ার জন্য `pool.map()` বা `pool.apply_async()`-এর মতো পদ্ধতি ব্যবহার করে।
    *   **ফলাফল সংগ্রহ:** সমস্ত টাস্ক সম্পূর্ণ হওয়ার জন্য অপেক্ষা করে এবং প্রতিটি কর্মী প্রসেস দ্বারা ফেরত দেওয়া ফলাফল সংগ্রহ করে।
    *   **একত্রিত ফলাফল বিশ্লেষণ এবং উপস্থাপনা:** পৃথক ফলাফল থেকে পরিসংখ্যানগত মেট্রিক (গড়, স্ট্যান্ডার্ড ডেভিয়েশন, সামগ্রিক সেরা) গণনা করে এবং সেগুলি উপস্থাপন করে বা একটি সারাংশ ফাইলে (যেমন, CSV) সংরক্ষণ করে।

### ৩.২. কর্মী সম্পাদন ফাংশন

এই ফাংশনটি `Pool`-এর প্রতিটি প্রসেস দ্বারা সম্পাদিত হয়।

*   **সাধারণ কাঠামো:**
    ```python
    def run_algorithm_worker(params):
        # প্যারামিটারগুলি আনপ্যাক করুন (অ্যালগরিদমের নাম, কনফিগারেশন, প্লেয়ার ডেটা, ইত্যাদি)
        algorithm_name, config, player_data, num_teams, ... = params

        # প্রাথমিক সমাধান তৈরি করুন (যদি প্রয়োজন হয়)
        initial_solution = LeagueSolution(player_data, ...)

        # অ্যালগরিদম সম্পাদন করুন (যেমন, hill_climbing, genetic_algorithm)
        start_time = time.time()
        if algorithm_name == 'HC':
            best_solution_data = evolution.hill_climbing(initial_solution, ...)
        elif algorithm_name == 'GA':
            best_solution_data = evolution.genetic_algorithm(player_data, ...)
        # ... অন্যান্য অ্যালগরিদম
        end_time = time.time()

        execution_time = end_time - start_time
        fitness = best_solution_data['best_fitness'] # বা অনুরূপ

        # প্রাসঙ্গিক ফলাফল ফেরত দিন (ফিটনেস, সময়, সম্ভবত সেরা সমাধান)
        return (fitness, execution_time, config_name) # উদাহরণ
    ```
*   **বিচ্ছিন্নতা:** এই ফাংশনের প্রতিটি কল একটি পৃথক প্রসেসে সম্পাদিত হয়, এটি নিশ্চিত করে যে রানগুলি স্বাধীন এবং সমস্যাযুক্তভাবে মেমরি ভাগ করে না (যদি না `multiprocessing` প্রক্রিয়াগুলির সাথে স্পষ্টভাবে পরিচালিত হয়)।

### ৩.৩. এসপি ধাপের মডিউল (`solution.py`, `evolution.py`, `operators.py`)

এই মডিউলগুলি তাদের অভ্যন্তরীণ যুক্তিতে উল্লেখযোগ্য পরিবর্তন ছাড়াই মূলত পুনরায় ব্যবহার করা হয়। প্রধান পরিবর্তন হল সেগুলি কীভাবে কল করা হয় (পৃথক প্রসেসে কর্মী ফাংশনের মাধ্যমে)।

*   **বিবেচনা:**
    *   **গ্লোবাল স্টেট:** যত্ন নেওয়া উচিত যে এই মডিউলগুলি গ্লোবাল স্টেটের উপর নির্ভর করে না যা প্রসেসগুলির মধ্যে সমবর্তী এবং असुरक्षितভাবে পরিবর্তিত হতে পারে। প্রকল্পের অনুশীলনে, ফাংশনগুলিতে সমস্ত প্রয়োজনীয় ডেটা (যেমন `player_data`) স্পষ্টভাবে পাস করা এটি প্রশমিত করতে সহায়তা করে।
    *   **সিরিয়ালাইজেশন:** প্রসেসগুলির মধ্যে পাস করা অবজেক্টগুলি (যেমন `initial_solution` বা প্যারামিটার) পাইথন দ্বারা সিরিয়ালাইজেবল (picklable) হতে হবে।

## ৪. এমপি ধাপে ডেটা প্রবাহ

১. এমপি প্রধান স্ক্রিপ্ট (যেমন, `main_script_mp.py`) প্লেয়ার ডেটা লোড করে এবং অ্যালগরিদম কনফিগারেশন এবং পুনরাবৃত্তির সংখ্যা নির্ধারণ করে।
২. এটি প্যারামিটার টাপলগুলির একটি তালিকা তৈরি করে, যেখানে প্রতিটি টাপলে একটি একক অ্যালগরিদম রানের জন্য প্রয়োজনীয় সবকিছু থাকে।
৩. একটি `multiprocessing.Pool` তৈরি করা হয়।
৪. প্যারামিটার টাপলগুলি `pool.map()` (বা অনুরূপ) ব্যবহার করে কর্মী ফাংশনে পাস করা হয়।
৫. `Pool`-এর প্রতিটি প্রসেস প্যারামিটারের একটি সেট সহ কর্মী ফাংশন সম্পাদন করে:
    ক. কর্মী ফাংশন `evolution.py` থেকে উপযুক্ত অ্যালগরিদমকে কল করে।
    খ. অ্যালগরিদম এসপি ধাপের মতো `solution.py` এবং `operators.py` ব্যবহার করে।
    গ. কর্মী ফাংশন তার রানের ফলাফল ফেরত দেয় (যেমন, ফিটনেস, সময়)।
৬. প্রধান স্ক্রিপ্ট সমস্ত রান থেকে ফলাফলের তালিকা সংগ্রহ করে।
৭. ফলাফলগুলি একত্রিত করা হয় (গড়, স্ট্যান্ডার্ড ডেভিয়েশন ইত্যাদি গণনা করে) এবং সংরক্ষণ বা উপস্থাপন করা হয়।

## ৫. এমপির জন্য ডিজাইন সিদ্ধান্ত এবং যৌক্তিকতা

*   **`multiprocessing.Pool`-এর ব্যবহার:** কর্মী প্রসেসগুলির একটি সেট পরিচালনা এবং টাস্ক বিতরণের জন্য একটি সুবিধাজনক, উচ্চ-স্তরের উপায় সরবরাহ করে, প্রসেস পরিচালনার অনেক নিম্ন-স্তরের বিবরণকে বিমূর্ত করে।
*   **কর্মী র‍্যাপার ফাংশন:** একটি একক রানের যুক্তিকে বিচ্ছিন্ন করে, কোডকে পরিষ্কার করে এবং সমান্তরালকরণ সহজতর করে।
*   **স্পষ্ট ডেটা পাসিং:** ভাগ করা স্টেটের সাথে সমস্যাগুলি হ্রাস করে, কারণ প্রতিটি কর্মী প্রসেস প্রয়োজনীয় ডেটার নিজস্ব অনুলিপি (বা অপরিবর্তনীয় ডেটার রেফারেন্স) পায়।
*   **এসপি কোড পুনঃব্যবহার:** এমপি আর্কিটেকচারটি এসপি ধাপের শক্ত ভিত্তির উপর নির্মিত হয়েছিল, অ্যালগরিদম এবং সমাধান মডিউলগুলি পুনরায় ব্যবহার করে, যা উন্নয়নকে ত্বরান্বিত করেছিল।
*   **CSV সারাংশ ফাইল:** একত্রিত ফলাফল সংরক্ষণ করতে CSV ফাইল ব্যবহার করা পরবর্তী বিশ্লেষণ এবং চার্ট/প্রতিবেদন তৈরি সহজতর করে।

## ৬. এমপি আর্কিটেকচারে চ্যালেঞ্জ এবং বিবেচনা

*   **মাল্টিপ্রসেসিং ওভারহেড:** প্রসেস তৈরি এবং আন্তঃ-প্রসেস যোগাযোগ (ডেটা সিরিয়ালাইজেশন/ডিসিরিয়ালাইজেশন) কিছু ওভারহেড প্রবর্তন করে। খুব ছোট টাস্কগুলির জন্য, এই ওভারহেড সমান্তরালকরণ থেকে লাভ হ্রাস করতে পারে।
*   **মেমরি খরচ:** প্রতিটি প্রসেসের কিছু ডেটার নিজস্ব অনুলিপি থাকতে পারে, যা মোট মেমরি খরচ বাড়াতে পারে, বিশেষ করে বড় ডেটাসেট বা GA-তে বড় জনসংখ্যার জন্য।
*   **ডিবাগিং:** মাল্টিপ্রসেস অ্যাপ্লিকেশন ডিবাগ করা অনুক্রমিক অ্যাপ্লিকেশনগুলির চেয়ে বেশি জটিল হতে পারে।
*   **প্রসেসের সর্বোত্তম সংখ্যা:** `Pool`-এ প্রসেসের আদর্শ সংখ্যা নির্ধারণ (সাধারণত সিপিইউ কোরগুলির সংখ্যার সাথে সম্পর্কিত) কর্মক্ষমতা অপ্টিমাইজ করার জন্য কিছু পরীক্ষার প্রয়োজন হতে পারে।

## ৭. প্রকল্পে এমপি আর্কিটেকচারের বিবর্তন

প্রকল্প জুড়ে, এমপি আর্কিটেকচার বিভিন্ন পরীক্ষামূলক পর্যায়গুলিকে સમાવવા জন্য বিভিন্ন প্রধান স্ক্রিপ্টের মাধ্যমে বিকশিত হয়েছে:

*   `main_script_mp.py`: প্রাথমিক ৫টি রানের জন্য।
*   `main_script_mp_30_runs.py`: প্রতিশ্রুতিশীল অ্যালগরিদমগুলির ৩০টি রানের জন্য।
*   `main_script_mp_param_var.py`: GA প্যারামিটার भिन्नতা পরীক্ষার জন্য (প্রতি भिन्नতা ৫ রান সহ)।
*   `main_script_mp_final_param_var.py`: সবচেয়ে প্রতিশ্রুতিশীল প্যারামিটার भिन्नতাগুলির ৩০টি রান সহ চূড়ান্ত বিশ্লেষণের জন্য।

মূল মাল্টিপ্রসেসিং যুক্তি (`Pool`-এর ব্যবহার, কর্মী ফাংশন) সামঞ্জস্যপূর্ণ ছিল, প্রধানত অ্যালগরিদম কনফিগারেশন এবং পরীক্ষামূলক লুপগুলি কীভাবে সংজ্ঞায়িত করা হয়েছিল তার भिन्नতা সহ।

এই আর্কিটেকচারটি একক-প্রসেসর ধাপের তুলনায় সমাধান স্থান এবং অ্যালগরিদম আচরণের অনেক বিস্তৃত এবং পরিসংখ্যানগতভাবে তাৎপর্যপূর্ণ অনুসন্ধানের অনুমতি দিয়েছে।

